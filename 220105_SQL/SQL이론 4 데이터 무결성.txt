데이터의 무결성
- 데이터베이스에 저장된 데이터값과 사용자가 의도한 데이터값은 일치해야한다
- 주민등록번호와 같은 값은 중복된 값이 있을 수 없다
- 중복된 값이나 null값이 입력되면 데이터 식별에 문제가 발생할 수 있음
- salary 열의 데이터 값에 숫자가 아닌 '오천만원' 문자가 입력된다면 큰 문제가 발생할 수 있음
- 데이터베이스 관리의 기본 규칙을 꼭 준수해야 함
-> 데이터베이스 시스템은 데이터에 접근하거나 데이터를 처리할 때마다 부적절한 데이터가 입력되는지 검사하여
   데이터의 결점이 없음 = 무결성을 유지하게 된다!

개체 무결성 : 고유해야하며, null 값을 가질 수 없다
참조 무결성 : 참조되는 외래키가 존재하면 행은 삭제될 수 없고 기본키도 변경될 수 없다
영역 무결성 : 데이터의 형태, 범위, 유일성에 관한 제한

제약 조건(constraint) : 정해놓은 데이터 관리 규칙 (데이터의 결함을 방지하기 위함)
- 제약 조건에 맞는 데이터만 입력받고 규칙에 어긋나는 데이터는 거부하여 "무결성을 지킴"
- 대표적인 제약조건으로는 기본키(PRIMARY KEY), 외래키(FOREIGN KEY)가 있음

	<기본키 PRIMARY KEY 제약 조건>
	- '중복을 허용하지 않고 NULL값을 허용하지 않음'이 자동으로 설정되어 중복값, NULL 입력 불가함
	- 대부분의 테이블은 중복을 방지하기 위해 기본키를 설정해야 하며, 오직 한 개의 기본키만 가질 수 있다
	- 테이블의 특성을 가장 잘 반영하는 열을 기본키로 선택하는 것이 바람직하다
	
	<외래키 FOREIGN KEY 제약 조건>
	- 두 테이블 사이의 관계를 연결해주고 그 결과데이터의 무결성을 보장해주는 역할
	- 외래키가 설정된 열은 반드시 다른 테이블의 기본키와 동일함
	- 기본키가 있는 테이블을 '기준테이블', 외래키가 있는 테이블은 '참조테이블'이라고 함

- 고유키 PK는 중복되지 않는 열에 지정해야 한다
- 값을 입력하는 제약조건 CHECK (ex. 신장 데이터는 300을 넘지 않기, 국적 데이터는 한국이 기본값..)
- 값을 반드시 입력해야 하는 제약조건 NOT NULL

	<고유키 제약조건 UNIQUE>
	- 중복되지 않는 유일한 값을 입력해야 하는 조건

<CHECK 제약조건>
- 입력할 때 데이터를 점검하는 기능
- ex. 어떤 열에 특정 값이 들어가지 않도록 제한 / '남,여' 둘 중 하나만 입력하도록 제한
- CHECK (조건)
- ALTER TABLE 테이블명 ADD CONSTRAINT CHECK(조건)

<Default 제약조건>
- 값을 입력하지 않았을 때 자동으로 입력될 값 = 기본값
- DEFAULT '값'
- ALTER TABLE 테이블명 ALTER COLUMN 열이름 SET DEFAULT 기본값;

Error report -
ORA-00001: unique constraint (HR.DEPT_ID_PK) violated
 = 첫 열에는 고유한(unique) 값만 입력되도록 제약 조건이 설정되어, 이미 존재하는 값을 삽입할 때의 오류

Error report -
ORA-01400: cannot insert NULL into ("HR"."DEPARTMENTS"."DEPARTMENT_ID")
 = 고유값을 입력해야하는 열에 null값을 넣었을 때 발생하는 오류

INSERT뿐만 아니라 UPDATE나 DELETE 명령어를 사용할 때도 제약조건의 준수 여부가 중요하다
무결성과 제약조건은 데이터를 정상으로 유지하기 위한 장치로, DML 명령어를 사용하기 전에 확인해야 한다

트랜잭션(transaction) : DML(삽입,갱신,삭제)과 관련된 논리적인 작업
- 데이터 무결성이 보장되는 상태에서 DML작업을 완수하기 위한 기본 작업 단위
	트랜잭션 논리 예시)
	은행 잔액 100만원 A계좌
	A -> B 10만원 이체
	A계좌 10만원 인출 / B계좌 10만원 입금 -> 트랜잭션 완료
- 트랜잭션의 처리가 완전히 끝나지 않았을 경우에는 전혀 이루어지지 않은 것과 같아야 함(all or nothing)
- 트랜잭션이 성공하면 결과를 영구적으로 보장해야한다
- 트랜잭션의 수행 단계 : 실행 -> 부분완료 -> (commit) -> 완료
커밋 commit : 트랜잭션의 모든 미결정 데이터(부분완료)를 영구적으로 반영함으로써 트랜잭션을 종료함(완료)
롤백 rollback : 트랜잭션의 모든 미결정 데이터 변경을 포기함으로 트랜잭션을 종료함(실행 전으로 되돌리기)


DDL Data Definition Language : 따로 커밋하지 않아도 즉각 자동으로 반영
- CREATE : 테이블 생성
CREATE TABLE sample_product
    (product_id number, product_name varchar(30), manu_date date);

INSERT INTO sample_product
VALUES (
1,'TV',to_date('140101','YYMMDD'));
INSERT INTO sample_product
VALUES (
2,'Washer',to_date('150101','YYMMDD'));
INSERT INTO sample_product
VALUES (
3,'Cleaner',to_date('160101','YYMMDD'));



<VIEW : 가상의 테이블>
- 테이블의 필요한 내용만 골라서 볼 수 있도록 함 -> 테이블과 아주 밀접하게 연관되어 있다
- 뷰는 한 번 생성하면 테이블이라고 생각해도 될 정도로 테이블과 동일한 객체로 취급된다. => 뷰 이름으로 테이블을 부르듯 사용할 수 있다!
- 뷰는 실제 데이터를 가지고 있는 건 아님 -> 뷰에 접근하는 순간 SELECT가 실행되는 것!
- 단순 뷰 : 하나의 테이블과 연관된 뷰 / 복합 뷰 : 2개 이상의 테이블과 연관된 뷰
- 어떤 테이블과 연계되었는지 알 수 있도록 v_연결테이블 등으로 이름을 사용하면 좋다
- 뷰를 사용하는 이유 1) 보안 Security - 직급별 열람 제한 등 2)복잡한 SQL 구문을 단순화 3) 데이터를 따로 보관
- 실무에서는 좀 더 복잡하게 사용됨

<특징>
- 자주 쓰거나 복잡한 SQL문의 결과를 미리 만들어 놓고 필요 시 바로 활용
- 여러 테이블을 조인하여 하나의 뷰로 생성 가능
- 사용자 별로 접근 권한을 다르게 할 수 있음
- 기본문법 : CREATE VIEW v_이름 AS SELECT 구문;
- 뷰 삭제 : DROP VIEW 뷰이름;
- 뷰 구조보기 : DESCRIBE 뷰이름;
- 뷰 소스보기 : SHOW CREATE VIEW 뷰이름;

<종류>
1. 심플뷰 : 하나의 테이블에서 뷰를 생성
2. 컴플렉스뷰 : 여러 개의 테이블을 조인하여 데이터를 생성
3. 인라인뷰 : SELECT 문의 FROM 절에 기술한 SELECT문

employees 테이블과 dept 테이블을 사용하여
employee_id, first_name, last_name, email, dname, loc















